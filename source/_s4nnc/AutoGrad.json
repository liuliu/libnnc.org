{
  "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift" : {
    "key.diagnostic_stage" : "source.diagnostic.stage.swift.parse",
    "key.length" : 8188,
    "key.offset" : 0,
    "key.substructure" : [
      {
        "key.annotated_decl" : "<Declaration>public class <Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.AnyTensor<\/Declaration>",
        "key.bodylength" : 1944,
        "key.bodyoffset" : 48,
        "key.doc.column" : 16,
        "key.doc.declaration" : "public class main.DynamicGraph.AnyTensor",
        "key.doc.file" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/DynamicGraph.swift",
        "key.doc.full_as_xml" : "<Class file=\"\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/DynamicGraph.swift\" line=\"33\" column=\"16\"><Name>AnyTensor<\/Name><USR>s:4main12DynamicGraphC9AnyTensorC<\/USR><Declaration>public class main.DynamicGraph.AnyTensor<\/Declaration><CommentParts><Abstract><Para>A type-erased tensor variable.<\/Para><\/Abstract><\/CommentParts><\/Class>",
        "key.doc.line" : 33,
        "key.doc.name" : "AnyTensor",
        "key.doc.type" : "Class",
        "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/DynamicGraph.swift",
        "key.fully_annotated_decl" : "<decl.class><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>class<\/syntaxtype.keyword> <ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<decl.name>AnyTensor<\/decl.name><\/decl.class>",
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 1979,
        "key.name" : "DynamicGraph.AnyTensor",
        "key.namelength" : 22,
        "key.nameoffset" : 24,
        "key.offset" : 14,
        "key.parsed_declaration" : "extension DynamicGraph.AnyTensor",
        "key.parsed_scope.end" : 56,
        "key.parsed_scope.start" : 3,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func backward&lt;S&gt;(to tensors: <Type usr=\"s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF1SL_xmfp\">S<\/Type>, streamContext: <Type usr=\"s:4main13StreamContextC\">StreamContext<\/Type>? = nil) where S : <Type usr=\"s:ST\">Sequence<\/Type>, S.Element : <Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 268
              }
            ],
            "key.bodylength" : 1219,
            "key.bodyoffset" : 397,
            "key.doc.column" : 15,
            "key.doc.comment" : " Compute gradients from this tensor to the source tensors.\n\n - Parameters:\n   - to: The source tensors to this tensor.\n   - streamContext: The stream context to perform such operation.",
            "key.doc.declaration" : "public func backward<S>(to tensors: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : main.DynamicGraph.AnyTensor",
            "key.doc.file" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift\" line=\"11\" column=\"15\"><Name>backward(to:streamContext:)<\/Name><USR>s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF<\/USR><Declaration>public func backward&lt;S&gt;(to tensors: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : main.DynamicGraph.AnyTensor<\/Declaration><CommentParts><Abstract><Para>Compute gradients from this tensor to the source tensors.<\/Para><\/Abstract><Parameters><Parameter><Name>to<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The source tensors to this tensor.<\/Para><\/Discussion><\/Parameter><Parameter><Name>streamContext<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The stream context to perform such operation.<\/Para><\/Discussion><\/Parameter><\/Parameters><\/CommentParts><\/Function>",
            "key.doc.line" : 11,
            "key.doc.name" : "backward(to:streamContext:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "The source tensors to this tensor."
                  }
                ],
                "name" : "to"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The stream context to perform such operation."
                  }
                ],
                "name" : "streamContext"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 214,
            "key.docoffset" : 51,
            "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>backward<\/decl.name>&lt;<decl.generic_type_param usr=\"s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF1SL_xmfp\"><decl.generic_type_param.name>S<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt;(<decl.var.parameter><decl.var.parameter.argument_label>to<\/decl.var.parameter.argument_label> <decl.var.parameter.name>tensors<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF1SL_xmfp\">S<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>streamContext<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:4main13StreamContextC\">StreamContext<\/ref.class>?<\/decl.var.parameter.type> = nil<\/decl.var.parameter>) <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>S : <ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol><\/decl.generic_type_requirement>, <decl.generic_type_requirement>S.Element : <ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class><\/decl.generic_type_requirement><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 1342,
            "key.name" : "backward(to:streamContext:)",
            "key.namelength" : 73,
            "key.nameoffset" : 280,
            "key.offset" : 275,
            "key.parsed_declaration" : "public func backward<S: Sequence>(to tensors: S, streamContext: StreamContext? = nil)\nwhere S.Element: DynamicGraph.AnyTensor",
            "key.parsed_scope.end" : 44,
            "key.parsed_scope.start" : 11,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyAE_AA06StreamI0CSgtF\">backward(to: DynamicGraph.AnyTensor, streamContext: StreamContext? = nil)<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>S : <Type usr=\"s:ST\">Sequence<\/Type><\/Declaration>",
                "key.elements" : [
                  {
                    "key.kind" : "source.lang.swift.structure.elem.typeref",
                    "key.length" : 8,
                    "key.offset" : 292
                  }
                ],
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.generic_type_param><decl.generic_type_param.name>S<\/decl.generic_type_param.name> : <decl.generic_type_param.constraint><ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol><\/decl.generic_type_param.constraint><\/decl.generic_type_param>",
                "key.inheritedtypes" : [
                  {
                    "key.name" : "Sequence"
                  }
                ],
                "key.kind" : "source.lang.swift.decl.generic_type_param",
                "key.length" : 11,
                "key.name" : "S",
                "key.namelength" : 1,
                "key.nameoffset" : 289,
                "key.offset" : 289,
                "key.parsed_declaration" : "public func backward<S: Sequence",
                "key.parsed_scope.end" : 11,
                "key.parsed_scope.start" : 11,
                "key.typename" : "S.Type",
                "key.typeusr" : "$sxmD",
                "key.usr" : "s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF1SL_xmfp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _graph: <Type usr=\"s:s13OpaquePointerV\">OpaquePointer<\/Type><\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_graph<\/decl.name>: <decl.var.type><ref.struct usr=\"s:s13OpaquePointerV\">OpaquePointer<\/ref.struct><\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 25,
                "key.name" : "_graph",
                "key.namelength" : 6,
                "key.nameoffset" : 406,
                "key.offset" : 402,
                "key.parsed_declaration" : "let _graph = graph._graph",
                "key.parsed_scope.end" : 13,
                "key.parsed_scope.start" : 13,
                "key.typename" : "OpaquePointer",
                "key.typeusr" : "$ss13OpaquePointerVD",
                "key.usr" : "s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF6_graphL_s13OpaquePointerVvp"
              },
              {
                "key.annotated_decl" : "<Declaration>var gradients: [<Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type>]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>gradients<\/decl.name>: <decl.var.type>[<ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class>]<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 44,
                "key.name" : "gradients",
                "key.namelength" : 9,
                "key.nameoffset" : 436,
                "key.offset" : 432,
                "key.parsed_declaration" : "var gradients = graph.gradients(for: [self])",
                "key.parsed_scope.end" : 14,
                "key.parsed_scope.start" : 14,
                "key.typename" : "[DynamicGraph.AnyTensor]",
                "key.typeusr" : "$sSay4main12DynamicGraphC9AnyTensorCGD",
                "key.usr" : "s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF9gradientsL_SayAEGvp"
              },
              {
                "key.annotated_decl" : "<Declaration>var gradientsSet: <Type usr=\"s:Sh\">Set<\/Type>&lt;<Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type>&gt;<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>gradientsSet<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Sh\">Set<\/ref.struct>&lt;<ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class>&gt;<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 33,
                "key.name" : "gradientsSet",
                "key.namelength" : 12,
                "key.nameoffset" : 485,
                "key.offset" : 481,
                "key.parsed_declaration" : "var gradientsSet = Set(gradients)",
                "key.parsed_scope.end" : 15,
                "key.parsed_scope.start" : 15,
                "key.typename" : "Set<DynamicGraph.AnyTensor>",
                "key.typeusr" : "$sShy4main12DynamicGraphC9AnyTensorCGD",
                "key.usr" : "s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF12gradientsSetL_ShyAEGvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _inputs: [ccv_nnc_tensor_variable_t?]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_inputs<\/decl.name>: <decl.var.type>[ccv_nnc_tensor_variable_t?]<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 72,
                "key.name" : "_inputs",
                "key.namelength" : 7,
                "key.nameoffset" : 676,
                "key.offset" : 672,
                "key.parsed_declaration" : "let _inputs: [ccv_nnc_tensor_variable_t?] = gradients.map { $0._tensor }",
                "key.parsed_scope.end" : 22,
                "key.parsed_scope.start" : 22,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF7_inputsL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let inputSize: &lt;&lt;error type&gt;&gt;<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>inputSize<\/decl.name>: <decl.var.type>&lt;&lt;error type&gt;&gt;<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 36,
                "key.name" : "inputSize",
                "key.namelength" : 9,
                "key.nameoffset" : 753,
                "key.offset" : 749,
                "key.parsed_declaration" : "let inputSize = Int32(_inputs.count)",
                "key.parsed_scope.end" : 23,
                "key.parsed_scope.start" : 23,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF9inputSizeL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _outputs: &lt;&lt;error type&gt;&gt;<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_outputs<\/decl.name>: <decl.var.type>&lt;&lt;error type&gt;&gt;<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 104,
                "key.name" : "_outputs",
                "key.namelength" : 8,
                "key.nameoffset" : 794,
                "key.offset" : 790,
                "key.parsed_declaration" : "let _outputs = UnsafeMutablePointer<ccv_nnc_tensor_variable_t?>.allocate(\n  capacity: _inputs.count)",
                "key.parsed_scope.end" : 24,
                "key.parsed_scope.start" : 24,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF8_outputsL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _streamContext: <Type usr=\"s:s13OpaquePointerV\">OpaquePointer<\/Type>?<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_streamContext<\/decl.name>: <decl.var.type><ref.struct usr=\"s:s13OpaquePointerV\">OpaquePointer<\/ref.struct>?<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 43,
                "key.name" : "_streamContext",
                "key.namelength" : 14,
                "key.nameoffset" : 1154,
                "key.offset" : 1150,
                "key.parsed_declaration" : "let _streamContext = streamContext?._stream",
                "key.parsed_scope.end" : 33,
                "key.parsed_scope.start" : 33,
                "key.typename" : "OpaquePointer?",
                "key.typeusr" : "$ss13OpaquePointerVSgD",
                "key.usr" : "s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF01_hI0L_s13OpaquePointerVSgvp"
              },
              {
                "key.annotated_decl" : "<Declaration>var f: ccv_nnc_tensor_variable_t?<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>f<\/decl.name>: <decl.var.type>ccv_nnc_tensor_variable_t?<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 48,
                "key.name" : "f",
                "key.namelength" : 1,
                "key.nameoffset" : 1202,
                "key.offset" : 1198,
                "key.parsed_declaration" : "var f: ccv_nnc_tensor_variable_t? = self._tensor",
                "key.parsed_scope.end" : 34,
                "key.parsed_scope.start" : 34,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF1fL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>var g: ccv_nnc_tensor_variable_t?<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>g<\/decl.name>: <decl.var.type>ccv_nnc_tensor_variable_t?<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 54,
                "key.name" : "g",
                "key.namelength" : 1,
                "key.nameoffset" : 1255,
                "key.offset" : 1251,
                "key.parsed_declaration" : "var g: ccv_nnc_tensor_variable_t? = self.grad?._tensor",
                "key.parsed_scope.end" : 35,
                "key.parsed_scope.start" : 35,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF1gL_Xevp"
              }
            ],
            "key.typename" : "<S where S : Sequence, S.Element : DynamicGraph.AnyTensor> (DynamicGraph.AnyTensor) -> (S, StreamContext?) -> ()",
            "key.typeusr" : "$s2to13streamContextyx_4main06StreamC0CSgtcSTRzAC12DynamicGraphC9AnyTensorC7ElementRczluD",
            "key.usr" : "s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func backward(to tensor: <Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type>, streamContext: <Type usr=\"s:4main13StreamContextC\">StreamContext<\/Type>? = nil)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 1836
              }
            ],
            "key.bodylength" : 60,
            "key.bodyoffset" : 1930,
            "key.doc.column" : 15,
            "key.doc.comment" : " Compute gradients from this tensor to the source tensor.\n\n - Parameters:\n   - to: The source tensor to this tensor.\n   - streamContext: The stream context to perform such operation.",
            "key.doc.declaration" : "public func backward(to tensor: DynamicGraph.AnyTensor, streamContext: StreamContext? = nil)",
            "key.doc.file" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift\" line=\"53\" column=\"15\"><Name>backward(to:streamContext:)<\/Name><USR>s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyAE_AA06StreamI0CSgtF<\/USR><Declaration>public func backward(to tensor: DynamicGraph.AnyTensor, streamContext: StreamContext? = nil)<\/Declaration><CommentParts><Abstract><Para>Compute gradients from this tensor to the source tensor.<\/Para><\/Abstract><Parameters><Parameter><Name>to<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The source tensor to this tensor.<\/Para><\/Discussion><\/Parameter><Parameter><Name>streamContext<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The stream context to perform such operation.<\/Para><\/Discussion><\/Parameter><\/Parameters><\/CommentParts><\/Function>",
            "key.doc.line" : 53,
            "key.doc.name" : "backward(to:streamContext:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "The source tensor to this tensor."
                  }
                ],
                "name" : "to"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The stream context to perform such operation."
                  }
                ],
                "name" : "streamContext"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 212,
            "key.docoffset" : 1621,
            "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>backward<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>to<\/decl.var.parameter.argument_label> <decl.var.parameter.name>tensor<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>streamContext<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:4main13StreamContextC\">StreamContext<\/ref.class>?<\/decl.var.parameter.type> = nil<\/decl.var.parameter>)<\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 148,
            "key.name" : "backward(to:streamContext:)",
            "key.namelength" : 80,
            "key.nameoffset" : 1848,
            "key.offset" : 1843,
            "key.parsed_declaration" : "public func backward(to tensor: DynamicGraph.AnyTensor, streamContext: StreamContext? = nil)",
            "key.parsed_scope.end" : 55,
            "key.parsed_scope.start" : 53,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyx_AA06StreamI0CSgtSTRzAE7ElementRczlF\">backward&lt;S&gt;(to: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : DynamicGraph.AnyTensor<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "(DynamicGraph.AnyTensor) -> (DynamicGraph.AnyTensor, StreamContext?) -> ()",
            "key.typeusr" : "$s2to13streamContexty4main12DynamicGraphC9AnyTensorC_AC06StreamC0CSgtcD",
            "key.usr" : "s:4main12DynamicGraphC9AnyTensorC8backward2to13streamContextyAE_AA06StreamI0CSgtF"
          }
        ],
        "key.typename" : "DynamicGraph.AnyTensor.Type",
        "key.typeusr" : "$s4main12DynamicGraphC9AnyTensorCmD",
        "key.usr" : "s:4main12DynamicGraphC9AnyTensorC"
      },
      {
        "key.annotated_decl" : "<Declaration>public struct Group&lt;Element&gt; : RandomAccessCollection, DynamicGraph.AnyGroup where Element : <Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type><\/Declaration>",
        "key.bodylength" : 1987,
        "key.bodyoffset" : 2025,
        "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/Group.swift",
        "key.fully_annotated_decl" : "<decl.struct><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>struct<\/syntaxtype.keyword> <decl.name>Group<\/decl.name>&lt;<decl.generic_type_param usr=\"s:4main12DynamicGraphC5GroupV7Elementxmfp\"><decl.generic_type_param.name>Element<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt; : RandomAccessCollection, DynamicGraph.AnyGroup <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>Element : <ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class><\/decl.generic_type_requirement><\/decl.struct>",
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 2018,
        "key.name" : "DynamicGraph.Group",
        "key.namelength" : 18,
        "key.nameoffset" : 2005,
        "key.offset" : 1995,
        "key.parsed_declaration" : "extension DynamicGraph.Group",
        "key.parsed_scope.end" : 110,
        "key.parsed_scope.start" : 58,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func backward&lt;S&gt;(to tensors: <Type usr=\"s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF1SL_qd__mfp\">S<\/Type>, streamContext: <Type usr=\"s:4main13StreamContextC\">StreamContext<\/Type>? = nil) where S : <Type usr=\"s:ST\">Sequence<\/Type>, S.Element : <Type usr=\"s:4main21DynamicGraph_AnyGroupP\">DynamicGraph_AnyGroup<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 2245
              }
            ],
            "key.bodylength" : 1242,
            "key.bodyoffset" : 2373,
            "key.doc.column" : 15,
            "key.doc.comment" : " Compute gradients from this tensor to the source tensors.\n\n - Parameters:\n   - to: The source tensors to this tensor.\n   - streamContext: The stream context to perform such operation.",
            "key.doc.declaration" : "public func backward<S>(to tensors: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : main.DynamicGraph_AnyGroup",
            "key.doc.file" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift\" line=\"66\" column=\"15\"><Name>backward(to:streamContext:)<\/Name><USR>s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF<\/USR><Declaration>public func backward&lt;S&gt;(to tensors: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : main.DynamicGraph_AnyGroup<\/Declaration><CommentParts><Abstract><Para>Compute gradients from this tensor to the source tensors.<\/Para><\/Abstract><Parameters><Parameter><Name>to<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The source tensors to this tensor.<\/Para><\/Discussion><\/Parameter><Parameter><Name>streamContext<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The stream context to perform such operation.<\/Para><\/Discussion><\/Parameter><\/Parameters><\/CommentParts><\/Function>",
            "key.doc.line" : 66,
            "key.doc.name" : "backward(to:streamContext:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "The source tensors to this tensor."
                  }
                ],
                "name" : "to"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The stream context to perform such operation."
                  }
                ],
                "name" : "streamContext"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 214,
            "key.docoffset" : 2028,
            "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>backward<\/decl.name>&lt;<decl.generic_type_param usr=\"s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF1SL_qd__mfp\"><decl.generic_type_param.name>S<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt;(<decl.var.parameter><decl.var.parameter.argument_label>to<\/decl.var.parameter.argument_label> <decl.var.parameter.name>tensors<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF1SL_qd__mfp\">S<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>streamContext<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:4main13StreamContextC\">StreamContext<\/ref.class>?<\/decl.var.parameter.type> = nil<\/decl.var.parameter>) <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>S : <ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol><\/decl.generic_type_requirement>, <decl.generic_type_requirement>S.Element : <ref.protocol usr=\"s:4main21DynamicGraph_AnyGroupP\">DynamicGraph_AnyGroup<\/ref.protocol><\/decl.generic_type_requirement><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 1364,
            "key.name" : "backward(to:streamContext:)",
            "key.namelength" : 73,
            "key.nameoffset" : 2257,
            "key.offset" : 2252,
            "key.parsed_declaration" : "public func backward<S: Sequence>(to tensors: S, streamContext: StreamContext? = nil)\nwhere S.Element: DynamicGraph.AnyGroup",
            "key.parsed_scope.end" : 96,
            "key.parsed_scope.start" : 66,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtAA0bc4_AnyD0Rd__lF\">backward&lt;Group&gt;(to: Group, streamContext: StreamContext? = nil) where Group : DynamicGraph_AnyGroup<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>S : <Type usr=\"s:ST\">Sequence<\/Type><\/Declaration>",
                "key.elements" : [
                  {
                    "key.kind" : "source.lang.swift.structure.elem.typeref",
                    "key.length" : 8,
                    "key.offset" : 2269
                  }
                ],
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.generic_type_param><decl.generic_type_param.name>S<\/decl.generic_type_param.name> : <decl.generic_type_param.constraint><ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol><\/decl.generic_type_param.constraint><\/decl.generic_type_param>",
                "key.inheritedtypes" : [
                  {
                    "key.name" : "Sequence"
                  }
                ],
                "key.kind" : "source.lang.swift.decl.generic_type_param",
                "key.length" : 11,
                "key.name" : "S",
                "key.namelength" : 1,
                "key.nameoffset" : 2266,
                "key.offset" : 2266,
                "key.parsed_declaration" : "public func backward<S: Sequence",
                "key.parsed_scope.end" : 66,
                "key.parsed_scope.start" : 66,
                "key.typename" : "S.Type",
                "key.typeusr" : "$sqd__mD",
                "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF1SL_qd__mfp"
              },
              {
                "key.annotated_decl" : "<Declaration>let graph: <Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type><\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>graph<\/decl.name>: <decl.var.type><ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class><\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 36,
                "key.name" : "graph",
                "key.namelength" : 5,
                "key.nameoffset" : 2426,
                "key.offset" : 2422,
                "key.parsed_declaration" : "let graph = underlyingArray[0].graph",
                "key.parsed_scope.end" : 69,
                "key.parsed_scope.start" : 69,
                "key.typename" : "DynamicGraph",
                "key.typeusr" : "$s4main12DynamicGraphCD",
                "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF5graphL_ACvp"
              },
              {
                "key.annotated_decl" : "<Declaration>var gradients: [<Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type>]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>gradients<\/decl.name>: <decl.var.type>[<ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class>]<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 53,
                "key.name" : "gradients",
                "key.namelength" : 9,
                "key.nameoffset" : 2467,
                "key.offset" : 2463,
                "key.parsed_declaration" : "var gradients = graph.gradients(for: underlyingArray)",
                "key.parsed_scope.end" : 70,
                "key.parsed_scope.start" : 70,
                "key.typename" : "[DynamicGraph.AnyTensor]",
                "key.typeusr" : "$sSay4main12DynamicGraphC9AnyTensorCGD",
                "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF9gradientsL_SayAC0J6TensorCGvp"
              },
              {
                "key.annotated_decl" : "<Declaration>var gradientsSet: <Type usr=\"s:Sh\">Set<\/Type>&lt;<Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type>&gt;<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>gradientsSet<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Sh\">Set<\/ref.struct>&lt;<ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class>&gt;<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 33,
                "key.name" : "gradientsSet",
                "key.namelength" : 12,
                "key.nameoffset" : 2525,
                "key.offset" : 2521,
                "key.parsed_declaration" : "var gradientsSet = Set(gradients)",
                "key.parsed_scope.end" : 71,
                "key.parsed_scope.start" : 71,
                "key.typename" : "Set<DynamicGraph.AnyTensor>",
                "key.typeusr" : "$sShy4main12DynamicGraphC9AnyTensorCGD",
                "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF12gradientsSetL_ShyAC0J6TensorCGvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _graph: <Type usr=\"s:s13OpaquePointerV\">OpaquePointer<\/Type><\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_graph<\/decl.name>: <decl.var.type><ref.struct usr=\"s:s13OpaquePointerV\">OpaquePointer<\/ref.struct><\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 25,
                "key.name" : "_graph",
                "key.namelength" : 6,
                "key.nameoffset" : 2740,
                "key.offset" : 2736,
                "key.parsed_declaration" : "let _graph = graph._graph",
                "key.parsed_scope.end" : 78,
                "key.parsed_scope.start" : 78,
                "key.typename" : "OpaquePointer",
                "key.typeusr" : "$ss13OpaquePointerVD",
                "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF6_graphL_s13OpaquePointerVvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _inputs: [ccv_nnc_tensor_variable_t?]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_inputs<\/decl.name>: <decl.var.type>[ccv_nnc_tensor_variable_t?]<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 72,
                "key.name" : "_inputs",
                "key.namelength" : 7,
                "key.nameoffset" : 2770,
                "key.offset" : 2766,
                "key.parsed_declaration" : "let _inputs: [ccv_nnc_tensor_variable_t?] = gradients.map { $0._tensor }",
                "key.parsed_scope.end" : 79,
                "key.parsed_scope.start" : 79,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF7_inputsL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let inputSize: &lt;&lt;error type&gt;&gt;<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>inputSize<\/decl.name>: <decl.var.type>&lt;&lt;error type&gt;&gt;<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 36,
                "key.name" : "inputSize",
                "key.namelength" : 9,
                "key.nameoffset" : 2847,
                "key.offset" : 2843,
                "key.parsed_declaration" : "let inputSize = Int32(_inputs.count)",
                "key.parsed_scope.end" : 80,
                "key.parsed_scope.start" : 80,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF9inputSizeL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _outputs: &lt;&lt;error type&gt;&gt;<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_outputs<\/decl.name>: <decl.var.type>&lt;&lt;error type&gt;&gt;<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 104,
                "key.name" : "_outputs",
                "key.namelength" : 8,
                "key.nameoffset" : 2888,
                "key.offset" : 2884,
                "key.parsed_declaration" : "let _outputs = UnsafeMutablePointer<ccv_nnc_tensor_variable_t?>.allocate(\n  capacity: _inputs.count)",
                "key.parsed_scope.end" : 81,
                "key.parsed_scope.start" : 81,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF8_outputsL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _streamContext: <Type usr=\"s:s13OpaquePointerV\">OpaquePointer<\/Type>?<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_streamContext<\/decl.name>: <decl.var.type><ref.struct usr=\"s:s13OpaquePointerV\">OpaquePointer<\/ref.struct>?<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 43,
                "key.name" : "_streamContext",
                "key.namelength" : 14,
                "key.nameoffset" : 3248,
                "key.offset" : 3244,
                "key.parsed_declaration" : "let _streamContext = streamContext?._stream",
                "key.parsed_scope.end" : 90,
                "key.parsed_scope.start" : 90,
                "key.typename" : "OpaquePointer?",
                "key.typeusr" : "$ss13OpaquePointerVSgD",
                "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF01_gH0L_s13OpaquePointerVSgvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let f: [ccv_nnc_tensor_variable_t?]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>f<\/decl.name>: <decl.var.type>[ccv_nnc_tensor_variable_t?]<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 77,
                "key.name" : "f",
                "key.namelength" : 1,
                "key.nameoffset" : 3296,
                "key.offset" : 3292,
                "key.parsed_declaration" : "let f: [ccv_nnc_tensor_variable_t?] = self.underlyingArray.map { $0._tensor }",
                "key.parsed_scope.end" : 91,
                "key.parsed_scope.start" : 91,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF1fL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let g: [ccv_nnc_tensor_variable_t?]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>g<\/decl.name>: <decl.var.type>[ccv_nnc_tensor_variable_t?]<\/decl.var.type><\/decl.var.local>",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 83,
                "key.name" : "g",
                "key.namelength" : 1,
                "key.nameoffset" : 3378,
                "key.offset" : 3374,
                "key.parsed_declaration" : "let g: [ccv_nnc_tensor_variable_t?] = self.underlyingArray.map { $0.grad?._tensor }",
                "key.parsed_scope.end" : 92,
                "key.parsed_scope.start" : 92,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF1gL_Xevp"
              }
            ],
            "key.typename" : "<Element, S where Element : DynamicGraph.AnyTensor, S : Sequence, S.Element : DynamicGraph_AnyGroup> (DynamicGraph.Group<Element>) -> (S, StreamContext?) -> ()",
            "key.typeusr" : "$s2to13streamContextyqd___4main06StreamC0CSgtcSTRd__AC21DynamicGraph_AnyGroup7ElementRpd__luD",
            "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func backward&lt;Group&gt;(to tensor: <Type usr=\"s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtAA0bc4_AnyD0Rd__lFADL_qd__mfp\">Group<\/Type>, streamContext: <Type usr=\"s:4main13StreamContextC\">StreamContext<\/Type>? = nil) where Group : <Type usr=\"s:4main21DynamicGraph_AnyGroupP\">DynamicGraph_AnyGroup<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 3835
              }
            ],
            "key.bodylength" : 60,
            "key.bodyoffset" : 3950,
            "key.doc.column" : 15,
            "key.doc.comment" : " Compute gradients from this tensor to the source tensor.\n\n - Parameters:\n   - to: The source tensor to this tensor.\n   - streamContext: The stream context to perform such operation.",
            "key.doc.declaration" : "public func backward<Group>(to tensor: Group, streamContext: StreamContext? = nil) where Group : main.DynamicGraph_AnyGroup",
            "key.doc.file" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift\" line=\"105\" column=\"15\"><Name>backward(to:streamContext:)<\/Name><USR>s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtAA0bc4_AnyD0Rd__lF<\/USR><Declaration>public func backward&lt;Group&gt;(to tensor: Group, streamContext: StreamContext? = nil) where Group : main.DynamicGraph_AnyGroup<\/Declaration><CommentParts><Abstract><Para>Compute gradients from this tensor to the source tensor.<\/Para><\/Abstract><Parameters><Parameter><Name>to<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The source tensor to this tensor.<\/Para><\/Discussion><\/Parameter><Parameter><Name>streamContext<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The stream context to perform such operation.<\/Para><\/Discussion><\/Parameter><\/Parameters><\/CommentParts><\/Function>",
            "key.doc.line" : 105,
            "key.doc.name" : "backward(to:streamContext:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "The source tensor to this tensor."
                  }
                ],
                "name" : "to"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The stream context to perform such operation."
                  }
                ],
                "name" : "streamContext"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 212,
            "key.docoffset" : 3620,
            "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>backward<\/decl.name>&lt;<decl.generic_type_param usr=\"s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtAA0bc4_AnyD0Rd__lFADL_qd__mfp\"><decl.generic_type_param.name>Group<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt;(<decl.var.parameter><decl.var.parameter.argument_label>to<\/decl.var.parameter.argument_label> <decl.var.parameter.name>tensor<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtAA0bc4_AnyD0Rd__lFADL_qd__mfp\">Group<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>streamContext<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:4main13StreamContextC\">StreamContext<\/ref.class>?<\/decl.var.parameter.type> = nil<\/decl.var.parameter>) <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>Group : <ref.protocol usr=\"s:4main21DynamicGraph_AnyGroupP\">DynamicGraph_AnyGroup<\/ref.protocol><\/decl.generic_type_requirement><\/decl.function.method.instance>",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 169,
            "key.name" : "backward(to:streamContext:)",
            "key.namelength" : 101,
            "key.nameoffset" : 3847,
            "key.offset" : 3842,
            "key.parsed_declaration" : "public func backward<Group: DynamicGraph.AnyGroup>(\n  to tensor: Group, streamContext: StreamContext? = nil\n)",
            "key.parsed_scope.end" : 109,
            "key.parsed_scope.start" : 105,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtSTRd__AA0bc4_AnyD07ElementRpd__lF\">backward&lt;S&gt;(to: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : DynamicGraph_AnyGroup<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>Group : <Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC8AnyGroupa\">AnyGroup<\/Type><\/Declaration>",
                "key.elements" : [
                  {
                    "key.kind" : "source.lang.swift.structure.elem.typeref",
                    "key.length" : 21,
                    "key.offset" : 3863
                  }
                ],
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.generic_type_param><decl.generic_type_param.name>Group<\/decl.generic_type_param.name> : <decl.generic_type_param.constraint><ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.typealias usr=\"s:4main12DynamicGraphC8AnyGroupa\">AnyGroup<\/ref.typealias><\/decl.generic_type_param.constraint><\/decl.generic_type_param>",
                "key.inheritedtypes" : [
                  {
                    "key.name" : "DynamicGraph.AnyGroup"
                  }
                ],
                "key.kind" : "source.lang.swift.decl.generic_type_param",
                "key.length" : 28,
                "key.name" : "Group",
                "key.namelength" : 5,
                "key.nameoffset" : 3856,
                "key.offset" : 3856,
                "key.parsed_declaration" : "public func backward<Group: DynamicGraph.AnyGroup",
                "key.parsed_scope.end" : 105,
                "key.parsed_scope.start" : 105,
                "key.typename" : "Group.Type",
                "key.typeusr" : "$sqd__mD",
                "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtAA0bc4_AnyD0Rd__lFADL_qd__mfp"
              }
            ],
            "key.typename" : "<Element, Group where Element : DynamicGraph.AnyTensor, Group : DynamicGraph_AnyGroup> (DynamicGraph.Group<Element>) -> (Group, StreamContext?) -> ()",
            "key.typeusr" : "$s2to13streamContextyqd___4main06StreamC0CSgtcAC21DynamicGraph_AnyGroupRd__luD",
            "key.usr" : "s:4main12DynamicGraphC5GroupV8backward2to13streamContextyqd___AA06StreamH0CSgtAA0bc4_AnyD0Rd__lF"
          }
        ],
        "key.typename" : "DynamicGraph.Group<Element>.Type",
        "key.typeusr" : "$s4main12DynamicGraphC5GroupVy_xGmD",
        "key.usr" : "s:4main12DynamicGraphC5GroupV"
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Collection : <Type usr=\"s:ST\">Sequence<\/Type><\/Declaration>",
        "key.bodylength" : 1940,
        "key.bodyoffset" : 4075,
        "key.doc.declaration" : "protocol Collection : Sequence",
        "key.doc.discussion" : [
          {
            "Para" : "Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the `Collection` protocol declares and implements. In addition to the operations that collections inherit from the `Sequence` protocol, you gain access to methods that depend on accessing an element at a specific position in a collection."
          },
          {
            "Para" : "For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `firstSpace` constant is an index into the `text` string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, `firstSpace` is used to extract the prefix that contains elements up to that index."
          },
          {
            "Para" : "You can access an element of a collection through its subscript by using any valid index except the collection’s `endIndex` property. This property is a “past the end” index that does not correspond with any element of the collection."
          },
          {
            "Para" : "Here’s an example of accessing the first character in a string through its subscript:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Collection` protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of `text` using the `first` property, which has the value of the first element of the collection, or `nil` if the collection is empty."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s `startIndex` property and finding every successor up to, and including, the `endIndex` property. All other values of the `Index` type, such as the `startIndex` property of a different collection, are invalid indices for this collection."
          },
          {
            "Para" : "Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the `MutableCollection` and `RangeReplaceableCollection` protocols, as well as for the specific type you’re using."
          },
          {
            "Para" : "You can access a slice of a collection through its ranged subscript or by calling methods like `prefix(while:)` or `suffix(_:)`. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics."
          },
          {
            "Para" : "The following example creates a `firstWord` constant by using the `prefix(while:)` method to get a slice of the `text` string."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can retrieve the same slice using the string’s ranged subscript, which takes a range expression."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The retrieved slice of `text` is equivalent in each of these cases."
          },
          {
            "Para" : "A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created."
          },
          {
            "Para" : "For example, suppose you have an array holding the number of absences from each class during a session."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:"
          },
          {
            "List-Number" : ""
          },
          {
            "Para" : "Here’s an implementation of those steps:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice."
          },
          {
            "Para" : "For example, if you update the last element of the `absences` array from `0` to `2`, the `secondHalf` slice is unchanged."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Although a sequence can be consumed as it is traversed, a collection is guaranteed to be : Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the `contains(_:)` method to test whether a collection includes an element."
          },
          {
            "Para" : "Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the `characters` view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the `Collection` protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add `Collection` conformance to your type, you must declare at least the following requirements:"
          },
          {
            "List-Bullet" : ""
          },
          {
            "Para" : "Types that conform to `Collection` are expected to provide the `startIndex` and `endIndex` properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees."
          },
          {
            "Para" : "The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its `count` property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its `count` property is an O() operation."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Collection<\/Name><USR>s:Sl<\/USR><Declaration>protocol Collection : Sequence<\/Declaration><CommentParts><Abstract><Para>A sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.<\/Para><\/Abstract><Discussion><Para>Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the <codeVoice>Collection<\/codeVoice> protocol declares and implements. In addition to the operations that collections inherit from the <codeVoice>Sequence<\/codeVoice> protocol, you gain access to methods that depend on accessing an element at a specific position in a collection.<\/Para><Para>For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let text = \"Buffalo buffalo buffalo buffalo.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>firstSpace<\/codeVoice> constant is an index into the <codeVoice>text<\/codeVoice> string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, <codeVoice>firstSpace<\/codeVoice> is used to extract the prefix that contains elements up to that index.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Individual Elements<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access an element of a collection through its subscript by using any valid index except the collection’s <codeVoice>endIndex<\/codeVoice> property. This property is a “past the end” index that does not correspond with any element of the collection.<\/Para><Para>Here’s an example of accessing the first character in a string through its subscript:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstChar = text[text.startIndex]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstChar)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"B\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Collection<\/codeVoice> protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of <codeVoice>text<\/codeVoice> using the <codeVoice>first<\/codeVoice> property, which has the value of the first element of the collection, or <codeVoice>nil<\/codeVoice> if the collection is empty.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(text.first)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Optional(\"B\")\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s <codeVoice>startIndex<\/codeVoice> property and finding every successor up to, and including, the <codeVoice>endIndex<\/codeVoice> property. All other values of the <codeVoice>Index<\/codeVoice> type, such as the <codeVoice>startIndex<\/codeVoice> property of a different collection, are invalid indices for this collection.<\/Para><Para>Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the <codeVoice>MutableCollection<\/codeVoice> and <codeVoice>RangeReplaceableCollection<\/codeVoice> protocols, as well as for the specific type you’re using.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Slices of a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access a slice of a collection through its ranged subscript or by calling methods like <codeVoice>prefix(while:)<\/codeVoice> or <codeVoice>suffix(_:)<\/codeVoice>. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics.<\/Para><Para>The following example creates a <codeVoice>firstWord<\/codeVoice> constant by using the <codeVoice>prefix(while:)<\/codeVoice> method to get a slice of the <codeVoice>text<\/codeVoice> string.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstWord = text.prefix(while: { $0 != \" \" })]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstWord)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can retrieve the same slice using the string’s ranged subscript, which takes a range expression.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The retrieved slice of <codeVoice>text<\/codeVoice> is equivalent in each of these cases.<\/Para><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Share Indices<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.<\/Para><Para>For example, suppose you have an array holding the number of absences from each class during a session.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var absences = [0, 2, 0, 4, 0, 3, 1, 0]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:<\/Para><List-Number><Item><Para>Create a slice of the <codeVoice>absences<\/codeVoice> array that holds the second half of the days.<\/Para><\/Item><Item><Para>Use the <codeVoice>max(by:)<\/codeVoice> method to determine the index of the day with the most absences.<\/Para><\/Item><Item><Para>Print the result using the index found in step 2 on the original <codeVoice>absences<\/codeVoice> array.<\/Para><\/Item><\/List-Number><Para>Here’s an implementation of those steps:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let secondHalf = absences.suffix(absences.count \/ 2)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let i = secondHalf.indices.max(by: { secondHalf[$0] < secondHalf[$1] }) {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Highest second-half absences: \\(absences[i])\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Highest second-half absences: 3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Inherit Collection Semantics<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice.<\/Para><Para>For example, if you update the last element of the <codeVoice>absences<\/codeVoice> array from <codeVoice>0<\/codeVoice> to <codeVoice>2<\/codeVoice>, the <codeVoice>secondHalf<\/codeVoice> slice is unchanged.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[absences[7] = 2]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(absences)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 2, 0, 4, 0, 3, 1, 2]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(secondHalf)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 3, 1, 0]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Traversing a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Although a sequence can be consumed as it is traversed, a collection is guaranteed to be <emphasis>multipass<\/emphasis>: Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the <codeVoice>contains(_:)<\/codeVoice> method to test whether a collection includes an element.<\/Para><Para>Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the <codeVoice>characters<\/codeVoice> view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let word = \"Swift\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for character in word {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(character)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in word.indices {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(word[i])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Collection Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the <codeVoice>Collection<\/codeVoice> protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add <codeVoice>Collection<\/codeVoice> conformance to your type, you must declare at least the following requirements:<\/Para><List-Bullet><Item><Para>The <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties<\/Para><\/Item><Item><Para>A subscript that provides at least read-only access to your type’s elements<\/Para><\/Item><Item><Para>The <codeVoice>index(after:)<\/codeVoice> method for advancing an index into your collection<\/Para><\/Item><\/List-Bullet><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Types that conform to <codeVoice>Collection<\/codeVoice> are expected to provide the <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees.<\/Para><Para>The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its <codeVoice>count<\/codeVoice> property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its <codeVoice>count<\/codeVoice> property is an O(<emphasis>n<\/emphasis>) operation.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Collection",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Collection<\/decl.name> : <ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 2001,
        "key.modulename" : "Swift",
        "key.name" : "Collection",
        "key.namelength" : 10,
        "key.nameoffset" : 4025,
        "key.offset" : 4015,
        "key.parsed_declaration" : "extension Collection where Element: DynamicGraph.AnyTensor",
        "key.parsed_scope.end" : 165,
        "key.parsed_scope.start" : 112,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func backward&lt;S&gt;(to tensors: <Type usr=\"s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF1SL_qd__mfp\">S<\/Type>, streamContext: <Type usr=\"s:4main13StreamContextC\">StreamContext<\/Type>? = nil) where S : <Type usr=\"s:ST\">Sequence<\/Type>, S.Element : <Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 4295
              }
            ],
            "key.bodylength" : 1215,
            "key.bodyoffset" : 4424,
            "key.doc.column" : 15,
            "key.doc.comment" : " Compute gradients from this tensor to the source tensors.\n\n - Parameters:\n   - to: The source tensors to this tensor.\n   - streamContext: The stream context to perform such operation.",
            "key.doc.declaration" : "public func backward<S>(to tensors: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : main.DynamicGraph.AnyTensor",
            "key.doc.file" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift\" line=\"120\" column=\"15\"><Name>backward(to:streamContext:)<\/Name><USR>s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF<\/USR><Declaration>public func backward&lt;S&gt;(to tensors: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : main.DynamicGraph.AnyTensor<\/Declaration><CommentParts><Abstract><Para>Compute gradients from this tensor to the source tensors.<\/Para><\/Abstract><Parameters><Parameter><Name>to<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The source tensors to this tensor.<\/Para><\/Discussion><\/Parameter><Parameter><Name>streamContext<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The stream context to perform such operation.<\/Para><\/Discussion><\/Parameter><\/Parameters><\/CommentParts><\/Function>",
            "key.doc.line" : 120,
            "key.doc.name" : "backward(to:streamContext:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "The source tensors to this tensor."
                  }
                ],
                "name" : "to"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The stream context to perform such operation."
                  }
                ],
                "name" : "streamContext"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 214,
            "key.docoffset" : 4078,
            "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>backward<\/decl.name>&lt;<decl.generic_type_param usr=\"s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF1SL_qd__mfp\"><decl.generic_type_param.name>S<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt;(<decl.var.parameter><decl.var.parameter.argument_label>to<\/decl.var.parameter.argument_label> <decl.var.parameter.name>tensors<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF1SL_qd__mfp\">S<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>streamContext<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:4main13StreamContextC\">StreamContext<\/ref.class>?<\/decl.var.parameter.type> = nil<\/decl.var.parameter>) <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>S : <ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol><\/decl.generic_type_requirement>, <decl.generic_type_requirement>S.Element : <ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class><\/decl.generic_type_requirement><\/decl.function.method.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 1338,
            "key.name" : "backward(to:streamContext:)",
            "key.namelength" : 73,
            "key.nameoffset" : 4307,
            "key.offset" : 4302,
            "key.parsed_declaration" : "public func backward<S: Sequence>(to tensors: S, streamContext: StreamContext? = nil)\nwhere S.Element: DynamicGraph.AnyTensor",
            "key.parsed_scope.end" : 153,
            "key.parsed_scope.start" : 120,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyAE_AA06StreamJ0CSgtF\">backward(to: DynamicGraph.AnyTensor, streamContext: StreamContext? = nil)<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF\">backward&lt;S&gt;(to: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : DynamicGraph_AnyGroup<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtAaBRd__lF\">backward&lt;Group&gt;(to: Group, streamContext: StreamContext? = nil) where Group : DynamicGraph_AnyGroup<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>S : <Type usr=\"s:ST\">Sequence<\/Type><\/Declaration>",
                "key.elements" : [
                  {
                    "key.kind" : "source.lang.swift.structure.elem.typeref",
                    "key.length" : 8,
                    "key.offset" : 4319
                  }
                ],
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.generic_type_param><decl.generic_type_param.name>S<\/decl.generic_type_param.name> : <decl.generic_type_param.constraint><ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol><\/decl.generic_type_param.constraint><\/decl.generic_type_param>",
                "key.groupname" : "Collection",
                "key.inheritedtypes" : [
                  {
                    "key.name" : "Sequence"
                  }
                ],
                "key.kind" : "source.lang.swift.decl.generic_type_param",
                "key.length" : 11,
                "key.name" : "S",
                "key.namelength" : 1,
                "key.nameoffset" : 4316,
                "key.offset" : 4316,
                "key.parsed_declaration" : "public func backward<S: Sequence",
                "key.parsed_scope.end" : 120,
                "key.parsed_scope.start" : 120,
                "key.typename" : "S.Type",
                "key.typeusr" : "$sqd__mD",
                "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF1SL_qd__mfp"
              },
              {
                "key.annotated_decl" : "<Declaration>let graph: <Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type><\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>graph<\/decl.name>: <decl.var.type><ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class><\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 29,
                "key.name" : "graph",
                "key.namelength" : 5,
                "key.nameoffset" : 4466,
                "key.offset" : 4462,
                "key.parsed_declaration" : "let graph = self.first!.graph",
                "key.parsed_scope.end" : 123,
                "key.parsed_scope.start" : 123,
                "key.typename" : "DynamicGraph",
                "key.typeusr" : "$s4main12DynamicGraphCD",
                "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF5graphL_ACvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _graph: <Type usr=\"s:s13OpaquePointerV\">OpaquePointer<\/Type><\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_graph<\/decl.name>: <decl.var.type><ref.struct usr=\"s:s13OpaquePointerV\">OpaquePointer<\/ref.struct><\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 25,
                "key.name" : "_graph",
                "key.namelength" : 6,
                "key.nameoffset" : 4558,
                "key.offset" : 4554,
                "key.parsed_declaration" : "let _graph = graph._graph",
                "key.parsed_scope.end" : 127,
                "key.parsed_scope.start" : 127,
                "key.typename" : "OpaquePointer",
                "key.typeusr" : "$ss13OpaquePointerVD",
                "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF6_graphL_s13OpaquePointerVvp"
              },
              {
                "key.annotated_decl" : "<Declaration>var gradients: [<Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type>]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>gradients<\/decl.name>: <decl.var.type>[<ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class>]<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 42,
                "key.name" : "gradients",
                "key.namelength" : 9,
                "key.nameoffset" : 4588,
                "key.offset" : 4584,
                "key.parsed_declaration" : "var gradients = graph.gradients(for: self)",
                "key.parsed_scope.end" : 128,
                "key.parsed_scope.start" : 128,
                "key.typename" : "[DynamicGraph.AnyTensor]",
                "key.typeusr" : "$sSay4main12DynamicGraphC9AnyTensorCGD",
                "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF9gradientsL_SayAEGvp"
              },
              {
                "key.annotated_decl" : "<Declaration>var gradientsSet: <Type usr=\"s:Sh\">Set<\/Type>&lt;<Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type>&gt;<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>gradientsSet<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Sh\">Set<\/ref.struct>&lt;<ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class>&gt;<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 33,
                "key.name" : "gradientsSet",
                "key.namelength" : 12,
                "key.nameoffset" : 4635,
                "key.offset" : 4631,
                "key.parsed_declaration" : "var gradientsSet = Set(gradients)",
                "key.parsed_scope.end" : 129,
                "key.parsed_scope.start" : 129,
                "key.typename" : "Set<DynamicGraph.AnyTensor>",
                "key.typeusr" : "$sShy4main12DynamicGraphC9AnyTensorCGD",
                "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF12gradientsSetL_ShyAEGvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _inputs: [ccv_nnc_tensor_variable_t?]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_inputs<\/decl.name>: <decl.var.type>[ccv_nnc_tensor_variable_t?]<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 72,
                "key.name" : "_inputs",
                "key.namelength" : 7,
                "key.nameoffset" : 4826,
                "key.offset" : 4822,
                "key.parsed_declaration" : "let _inputs: [ccv_nnc_tensor_variable_t?] = gradients.map { $0._tensor }",
                "key.parsed_scope.end" : 136,
                "key.parsed_scope.start" : 136,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF7_inputsL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let inputSize: &lt;&lt;error type&gt;&gt;<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>inputSize<\/decl.name>: <decl.var.type>&lt;&lt;error type&gt;&gt;<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 36,
                "key.name" : "inputSize",
                "key.namelength" : 9,
                "key.nameoffset" : 4903,
                "key.offset" : 4899,
                "key.parsed_declaration" : "let inputSize = Int32(_inputs.count)",
                "key.parsed_scope.end" : 137,
                "key.parsed_scope.start" : 137,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF9inputSizeL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _outputs: &lt;&lt;error type&gt;&gt;<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_outputs<\/decl.name>: <decl.var.type>&lt;&lt;error type&gt;&gt;<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 104,
                "key.name" : "_outputs",
                "key.namelength" : 8,
                "key.nameoffset" : 4944,
                "key.offset" : 4940,
                "key.parsed_declaration" : "let _outputs = UnsafeMutablePointer<ccv_nnc_tensor_variable_t?>.allocate(\n  capacity: _inputs.count)",
                "key.parsed_scope.end" : 138,
                "key.parsed_scope.start" : 138,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF8_outputsL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _streamContext: <Type usr=\"s:s13OpaquePointerV\">OpaquePointer<\/Type>?<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_streamContext<\/decl.name>: <decl.var.type><ref.struct usr=\"s:s13OpaquePointerV\">OpaquePointer<\/ref.struct>?<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 43,
                "key.name" : "_streamContext",
                "key.namelength" : 14,
                "key.nameoffset" : 5304,
                "key.offset" : 5300,
                "key.parsed_declaration" : "let _streamContext = streamContext?._stream",
                "key.parsed_scope.end" : 147,
                "key.parsed_scope.start" : 147,
                "key.typename" : "OpaquePointer?",
                "key.typeusr" : "$ss13OpaquePointerVSgD",
                "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF01_iJ0L_s13OpaquePointerVSgvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let f: [ccv_nnc_tensor_variable_t?]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>f<\/decl.name>: <decl.var.type>[ccv_nnc_tensor_variable_t?]<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 61,
                "key.name" : "f",
                "key.namelength" : 1,
                "key.nameoffset" : 5352,
                "key.offset" : 5348,
                "key.parsed_declaration" : "let f: [ccv_nnc_tensor_variable_t?] = self.map { $0._tensor }",
                "key.parsed_scope.end" : 148,
                "key.parsed_scope.start" : 148,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF1fL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let g: [ccv_nnc_tensor_variable_t?]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>g<\/decl.name>: <decl.var.type>[ccv_nnc_tensor_variable_t?]<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 67,
                "key.name" : "g",
                "key.namelength" : 1,
                "key.nameoffset" : 5418,
                "key.offset" : 5414,
                "key.parsed_declaration" : "let g: [ccv_nnc_tensor_variable_t?] = self.map { $0.grad?._tensor }",
                "key.parsed_scope.end" : 149,
                "key.parsed_scope.start" : 149,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF1gL_Xevp"
              }
            ],
            "key.typename" : "<Self, S where Self : Collection, S : Sequence, Self.Element : DynamicGraph.AnyTensor, S.Element : DynamicGraph.AnyTensor> (Self) -> (S, StreamContext?) -> ()",
            "key.typeusr" : "$s2to13streamContextyqd___4main06StreamC0CSgtcSTRd__AC12DynamicGraphC9AnyTensorC7ElementRcd__luD",
            "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func backward(to tensor: <Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type>, streamContext: <Type usr=\"s:4main13StreamContextC\">StreamContext<\/Type>? = nil)<\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 5859
              }
            ],
            "key.bodylength" : 60,
            "key.bodyoffset" : 5953,
            "key.doc.column" : 15,
            "key.doc.comment" : " Compute gradients from this tensor to the source tensor.\n\n - Parameters:\n   - to: The source tensor to this tensor.\n   - streamContext: The stream context to perform such operation.",
            "key.doc.declaration" : "public func backward(to tensor: DynamicGraph.AnyTensor, streamContext: StreamContext? = nil)",
            "key.doc.file" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift\" line=\"162\" column=\"15\"><Name>backward(to:streamContext:)<\/Name><USR>s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyAE_AA06StreamJ0CSgtF<\/USR><Declaration>public func backward(to tensor: DynamicGraph.AnyTensor, streamContext: StreamContext? = nil)<\/Declaration><CommentParts><Abstract><Para>Compute gradients from this tensor to the source tensor.<\/Para><\/Abstract><Parameters><Parameter><Name>to<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The source tensor to this tensor.<\/Para><\/Discussion><\/Parameter><Parameter><Name>streamContext<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The stream context to perform such operation.<\/Para><\/Discussion><\/Parameter><\/Parameters><\/CommentParts><\/Function>",
            "key.doc.line" : 162,
            "key.doc.name" : "backward(to:streamContext:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "The source tensor to this tensor."
                  }
                ],
                "name" : "to"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The stream context to perform such operation."
                  }
                ],
                "name" : "streamContext"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 212,
            "key.docoffset" : 5644,
            "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>backward<\/decl.name>(<decl.var.parameter><decl.var.parameter.argument_label>to<\/decl.var.parameter.argument_label> <decl.var.parameter.name>tensor<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>streamContext<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:4main13StreamContextC\">StreamContext<\/ref.class>?<\/decl.var.parameter.type> = nil<\/decl.var.parameter>)<\/decl.function.method.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 148,
            "key.name" : "backward(to:streamContext:)",
            "key.namelength" : 80,
            "key.nameoffset" : 5871,
            "key.offset" : 5866,
            "key.parsed_declaration" : "public func backward(to tensor: DynamicGraph.AnyTensor, streamContext: StreamContext? = nil)",
            "key.parsed_scope.end" : 164,
            "key.parsed_scope.start" : 162,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF\">backward&lt;S&gt;(to: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : DynamicGraph.AnyTensor<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF\">backward&lt;S&gt;(to: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : DynamicGraph_AnyGroup<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtAaBRd__lF\">backward&lt;Group&gt;(to: Group, streamContext: StreamContext? = nil) where Group : DynamicGraph_AnyGroup<\/RelatedName>"
              }
            ],
            "key.substructure" : [

            ],
            "key.typename" : "<Self where Self : Collection, Self.Element : DynamicGraph.AnyTensor> (Self) -> (DynamicGraph.AnyTensor, StreamContext?) -> ()",
            "key.typeusr" : "$s2to13streamContexty4main12DynamicGraphC9AnyTensorC_AC06StreamC0CSgtcD",
            "key.usr" : "s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyAE_AA06StreamJ0CSgtF"
          }
        ],
        "key.typename" : "Collection.Protocol",
        "key.typeusr" : "$sSl_pmD",
        "key.usr" : "s:Sl"
      },
      {
        "key.annotated_decl" : "<Declaration>protocol Collection : <Type usr=\"s:ST\">Sequence<\/Type><\/Declaration>",
        "key.bodylength" : 2109,
        "key.bodyoffset" : 6077,
        "key.doc.declaration" : "protocol Collection : Sequence",
        "key.doc.discussion" : [
          {
            "Para" : "Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the `Collection` protocol declares and implements. In addition to the operations that collections inherit from the `Sequence` protocol, you gain access to methods that depend on accessing an element at a specific position in a collection."
          },
          {
            "Para" : "For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `firstSpace` constant is an index into the `text` string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, `firstSpace` is used to extract the prefix that contains elements up to that index."
          },
          {
            "Para" : "You can access an element of a collection through its subscript by using any valid index except the collection’s `endIndex` property. This property is a “past the end” index that does not correspond with any element of the collection."
          },
          {
            "Para" : "Here’s an example of accessing the first character in a string through its subscript:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The `Collection` protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of `text` using the `first` property, which has the value of the first element of the collection, or `nil` if the collection is empty."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s `startIndex` property and finding every successor up to, and including, the `endIndex` property. All other values of the `Index` type, such as the `startIndex` property of a different collection, are invalid indices for this collection."
          },
          {
            "Para" : "Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the `MutableCollection` and `RangeReplaceableCollection` protocols, as well as for the specific type you’re using."
          },
          {
            "Para" : "You can access a slice of a collection through its ranged subscript or by calling methods like `prefix(while:)` or `suffix(_:)`. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics."
          },
          {
            "Para" : "The following example creates a `firstWord` constant by using the `prefix(while:)` method to get a slice of the `text` string."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You can retrieve the same slice using the string’s ranged subscript, which takes a range expression."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "The retrieved slice of `text` is equivalent in each of these cases."
          },
          {
            "Para" : "A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created."
          },
          {
            "Para" : "For example, suppose you have an array holding the number of absences from each class during a session."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:"
          },
          {
            "List-Number" : ""
          },
          {
            "Para" : "Here’s an implementation of those steps:"
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice."
          },
          {
            "Para" : "For example, if you update the last element of the `absences` array from `0` to `2`, the `secondHalf` slice is unchanged."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "Although a sequence can be consumed as it is traversed, a collection is guaranteed to be : Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the `contains(_:)` method to test whether a collection includes an element."
          },
          {
            "Para" : "Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the `characters` view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated."
          },
          {
            "CodeListing" : ""
          },
          {
            "Para" : "If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the `Collection` protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add `Collection` conformance to your type, you must declare at least the following requirements:"
          },
          {
            "List-Bullet" : ""
          },
          {
            "Para" : "Types that conform to `Collection` are expected to provide the `startIndex` and `endIndex` properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees."
          },
          {
            "Para" : "The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its `count` property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its `count` property is an O() operation."
          }
        ],
        "key.doc.full_as_xml" : "<Class><Name>Collection<\/Name><USR>s:Sl<\/USR><Declaration>protocol Collection : Sequence<\/Declaration><CommentParts><Abstract><Para>A sequence whose elements can be traversed multiple times, nondestructively, and accessed by an indexed subscript.<\/Para><\/Abstract><Discussion><Para>Collections are used extensively throughout the standard library. When you use arrays, dictionaries, and other collections, you benefit from the operations that the <codeVoice>Collection<\/codeVoice> protocol declares and implements. In addition to the operations that collections inherit from the <codeVoice>Sequence<\/codeVoice> protocol, you gain access to methods that depend on accessing an element at a specific position in a collection.<\/Para><Para>For example, if you want to print only the first word in a string, you can search for the index of the first space, and then create a substring up to that position.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let text = \"Buffalo buffalo buffalo buffalo.\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>firstSpace<\/codeVoice> constant is an index into the <codeVoice>text<\/codeVoice> string—the position of the first space in the string. You can store indices in variables, and pass them to collection algorithms or use them later to access the corresponding element. In the example above, <codeVoice>firstSpace<\/codeVoice> is used to extract the prefix that contains elements up to that index.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Individual Elements<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access an element of a collection through its subscript by using any valid index except the collection’s <codeVoice>endIndex<\/codeVoice> property. This property is a “past the end” index that does not correspond with any element of the collection.<\/Para><Para>Here’s an example of accessing the first character in a string through its subscript:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstChar = text[text.startIndex]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstChar)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"B\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The <codeVoice>Collection<\/codeVoice> protocol declares and provides default implementations for many operations that depend on elements being accessible by their subscript. For example, you can also access the first character of <codeVoice>text<\/codeVoice> using the <codeVoice>first<\/codeVoice> property, which has the value of the first element of the collection, or <codeVoice>nil<\/codeVoice> if the collection is empty.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[print(text.first)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Optional(\"B\")\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can pass only valid indices to collection operations. You can find a complete set of a collection’s valid indices by starting with the collection’s <codeVoice>startIndex<\/codeVoice> property and finding every successor up to, and including, the <codeVoice>endIndex<\/codeVoice> property. All other values of the <codeVoice>Index<\/codeVoice> type, such as the <codeVoice>startIndex<\/codeVoice> property of a different collection, are invalid indices for this collection.<\/Para><Para>Saved indices may become invalid as a result of mutating operations. For more information about index invalidation in mutable collections, see the reference for the <codeVoice>MutableCollection<\/codeVoice> and <codeVoice>RangeReplaceableCollection<\/codeVoice> protocols, as well as for the specific type you’re using.<\/Para><rawHTML><![CDATA[<h1>]]><\/rawHTML>Accessing Slices of a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>You can access a slice of a collection through its ranged subscript or by calling methods like <codeVoice>prefix(while:)<\/codeVoice> or <codeVoice>suffix(_:)<\/codeVoice>. A slice of a collection can contain zero or more of the original collection’s elements and shares the original collection’s semantics.<\/Para><Para>The following example creates a <codeVoice>firstWord<\/codeVoice> constant by using the <codeVoice>prefix(while:)<\/codeVoice> method to get a slice of the <codeVoice>text<\/codeVoice> string.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let firstWord = text.prefix(while: { $0 != \" \" })]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(firstWord)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You can retrieve the same slice using the string’s ranged subscript, which takes a range expression.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[if let firstSpace = text.firstIndex(of: \" \") {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(text[..<firstSpace]]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    \/\/ Prints \"Buffalo\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>The retrieved slice of <codeVoice>text<\/codeVoice> is equivalent in each of these cases.<\/Para><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Share Indices<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A collection and its slices share the same indices. An element of a collection is located under the same index in a slice as in the base collection, as long as neither the collection nor the slice has been mutated since the slice was created.<\/Para><Para>For example, suppose you have an array holding the number of absences from each class during a session.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[var absences = [0, 2, 0, 4, 0, 3, 1, 0]]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><Para>You’re tasked with finding the day with the most absences in the second half of the session. To find the index of the day in question, follow these steps:<\/Para><List-Number><Item><Para>Create a slice of the <codeVoice>absences<\/codeVoice> array that holds the second half of the days.<\/Para><\/Item><Item><Para>Use the <codeVoice>max(by:)<\/codeVoice> method to determine the index of the day with the most absences.<\/Para><\/Item><Item><Para>Print the result using the index found in step 2 on the original <codeVoice>absences<\/codeVoice> array.<\/Para><\/Item><\/List-Number><Para>Here’s an implementation of those steps:<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let secondHalf = absences.suffix(absences.count \/ 2)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[if let i = secondHalf.indices.max(by: { secondHalf[$0] < secondHalf[$1] }) {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(\"Highest second-half absences: \\(absences[i])\")]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"Highest second-half absences: 3\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h2>]]><\/rawHTML>Slices Inherit Collection Semantics<rawHTML><![CDATA[<\/h2>]]><\/rawHTML><Para>A slice inherits the value or reference semantics of its base collection. That is, when working with a slice of a mutable collection that has value semantics, such as an array, mutating the original collection triggers a copy of that collection and does not affect the contents of the slice.<\/Para><Para>For example, if you update the last element of the <codeVoice>absences<\/codeVoice> array from <codeVoice>0<\/codeVoice> to <codeVoice>2<\/codeVoice>, the <codeVoice>secondHalf<\/codeVoice> slice is unchanged.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[absences[7] = 2]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(absences)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 2, 0, 4, 0, 3, 1, 2]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[print(secondHalf)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"[0, 3, 1, 0]\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Traversing a Collection<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Although a sequence can be consumed as it is traversed, a collection is guaranteed to be <emphasis>multipass<\/emphasis>: Any element can be repeatedly accessed by saving its index. Moreover, a collection’s indices form a finite range of the positions of the collection’s elements. The fact that all collections are finite guarantees the safety of many sequence operations, such as using the <codeVoice>contains(_:)<\/codeVoice> method to test whether a collection includes an element.<\/Para><Para>Iterating over the elements of a collection by their positions yields the same elements in the same order as iterating over that collection using its iterator. This example demonstrates that the <codeVoice>characters<\/codeVoice> view of a string returns the same characters in the same order whether the view’s indices or the view itself is being iterated.<\/Para><CodeListing language=\"swift\"><zCodeLineNumbered><![CDATA[let word = \"Swift\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for character in word {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(character)]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[for i in word.indices {]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[    print(word[i])]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[}]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"S\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"w\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"i\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"f\"]]><\/zCodeLineNumbered><zCodeLineNumbered><![CDATA[\/\/ Prints \"t\"]]><\/zCodeLineNumbered><zCodeLineNumbered><\/zCodeLineNumbered><\/CodeListing><rawHTML><![CDATA[<h1>]]><\/rawHTML>Conforming to the Collection Protocol<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>If you create a custom sequence that can provide repeated access to its elements, make sure that its type conforms to the <codeVoice>Collection<\/codeVoice> protocol in order to give a more useful and more efficient interface for sequence and collection operations. To add <codeVoice>Collection<\/codeVoice> conformance to your type, you must declare at least the following requirements:<\/Para><List-Bullet><Item><Para>The <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties<\/Para><\/Item><Item><Para>A subscript that provides at least read-only access to your type’s elements<\/Para><\/Item><Item><Para>The <codeVoice>index(after:)<\/codeVoice> method for advancing an index into your collection<\/Para><\/Item><\/List-Bullet><rawHTML><![CDATA[<h1>]]><\/rawHTML>Expected Performance<rawHTML><![CDATA[<\/h1>]]><\/rawHTML><Para>Types that conform to <codeVoice>Collection<\/codeVoice> are expected to provide the <codeVoice>startIndex<\/codeVoice> and <codeVoice>endIndex<\/codeVoice> properties and subscript access to elements as O(1) operations. Types that are not able to guarantee this performance must document the departure, because many collection operations depend on O(1) subscripting performance for their own performance guarantees.<\/Para><Para>The performance of some collection operations depends on the type of index that the collection provides. For example, a random-access collection, which can measure the distance between two indices in O(1) time, can calculate its <codeVoice>count<\/codeVoice> property in O(1) time. Conversely, because a forward or bidirectional collection must traverse the entire collection to count the number of contained elements, accessing its <codeVoice>count<\/codeVoice> property is an O(<emphasis>n<\/emphasis>) operation.<\/Para><\/Discussion><\/CommentParts><\/Class>",
        "key.doc.name" : "Collection",
        "key.doc.type" : "Class",
        "key.fully_annotated_decl" : "<decl.protocol><syntaxtype.keyword>protocol<\/syntaxtype.keyword> <decl.name>Collection<\/decl.name> : <ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol><\/decl.protocol>",
        "key.groupname" : "Collection",
        "key.is_system" : true,
        "key.kind" : "source.lang.swift.decl.extension",
        "key.length" : 2169,
        "key.modulename" : "Swift",
        "key.name" : "Collection",
        "key.namelength" : 10,
        "key.nameoffset" : 6028,
        "key.offset" : 6018,
        "key.parsed_declaration" : "extension Collection where Element: DynamicGraph.AnyGroup",
        "key.parsed_scope.end" : 224,
        "key.parsed_scope.start" : 167,
        "key.substructure" : [
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func backward&lt;S&gt;(to tensors: <Type usr=\"s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF1SL_qd__mfp\">S<\/Type>, streamContext: <Type usr=\"s:4main13StreamContextC\">StreamContext<\/Type>? = nil) where S : <Type usr=\"s:ST\">Sequence<\/Type>, S.Element : <Type usr=\"s:4main21DynamicGraph_AnyGroupP\">DynamicGraph_AnyGroup<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 6297
              }
            ],
            "key.bodylength" : 1364,
            "key.bodyoffset" : 6425,
            "key.doc.column" : 15,
            "key.doc.comment" : " Compute gradients from this tensor to the source tensors.\n\n - Parameters:\n   - to: The source tensors to this tensor.\n   - streamContext: The stream context to perform such operation.",
            "key.doc.declaration" : "public func backward<S>(to tensors: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : main.DynamicGraph_AnyGroup",
            "key.doc.file" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift\" line=\"175\" column=\"15\"><Name>backward(to:streamContext:)<\/Name><USR>s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF<\/USR><Declaration>public func backward&lt;S&gt;(to tensors: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : main.DynamicGraph_AnyGroup<\/Declaration><CommentParts><Abstract><Para>Compute gradients from this tensor to the source tensors.<\/Para><\/Abstract><Parameters><Parameter><Name>to<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The source tensors to this tensor.<\/Para><\/Discussion><\/Parameter><Parameter><Name>streamContext<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The stream context to perform such operation.<\/Para><\/Discussion><\/Parameter><\/Parameters><\/CommentParts><\/Function>",
            "key.doc.line" : 175,
            "key.doc.name" : "backward(to:streamContext:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "The source tensors to this tensor."
                  }
                ],
                "name" : "to"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The stream context to perform such operation."
                  }
                ],
                "name" : "streamContext"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 214,
            "key.docoffset" : 6080,
            "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>backward<\/decl.name>&lt;<decl.generic_type_param usr=\"s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF1SL_qd__mfp\"><decl.generic_type_param.name>S<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt;(<decl.var.parameter><decl.var.parameter.argument_label>to<\/decl.var.parameter.argument_label> <decl.var.parameter.name>tensors<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF1SL_qd__mfp\">S<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>streamContext<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:4main13StreamContextC\">StreamContext<\/ref.class>?<\/decl.var.parameter.type> = nil<\/decl.var.parameter>) <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>S : <ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol><\/decl.generic_type_requirement>, <decl.generic_type_requirement>S.Element : <ref.protocol usr=\"s:4main21DynamicGraph_AnyGroupP\">DynamicGraph_AnyGroup<\/ref.protocol><\/decl.generic_type_requirement><\/decl.function.method.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 1486,
            "key.name" : "backward(to:streamContext:)",
            "key.namelength" : 73,
            "key.nameoffset" : 6309,
            "key.offset" : 6304,
            "key.parsed_declaration" : "public func backward<S: Sequence>(to tensors: S, streamContext: StreamContext? = nil)\nwhere S.Element: DynamicGraph.AnyGroup",
            "key.parsed_scope.end" : 210,
            "key.parsed_scope.start" : 175,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF\">backward&lt;S&gt;(to: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : DynamicGraph.AnyTensor<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyAE_AA06StreamJ0CSgtF\">backward(to: DynamicGraph.AnyTensor, streamContext: StreamContext? = nil)<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtAaBRd__lF\">backward&lt;Group&gt;(to: Group, streamContext: StreamContext? = nil) where Group : DynamicGraph_AnyGroup<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>S : <Type usr=\"s:ST\">Sequence<\/Type><\/Declaration>",
                "key.elements" : [
                  {
                    "key.kind" : "source.lang.swift.structure.elem.typeref",
                    "key.length" : 8,
                    "key.offset" : 6321
                  }
                ],
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.generic_type_param><decl.generic_type_param.name>S<\/decl.generic_type_param.name> : <decl.generic_type_param.constraint><ref.protocol usr=\"s:ST\">Sequence<\/ref.protocol><\/decl.generic_type_param.constraint><\/decl.generic_type_param>",
                "key.groupname" : "Collection",
                "key.inheritedtypes" : [
                  {
                    "key.name" : "Sequence"
                  }
                ],
                "key.kind" : "source.lang.swift.decl.generic_type_param",
                "key.length" : 11,
                "key.name" : "S",
                "key.namelength" : 1,
                "key.nameoffset" : 6318,
                "key.offset" : 6318,
                "key.parsed_declaration" : "public func backward<S: Sequence",
                "key.parsed_scope.end" : 175,
                "key.parsed_scope.start" : 175,
                "key.typename" : "S.Type",
                "key.typeusr" : "$sqd__mD",
                "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF1SL_qd__mfp"
              },
              {
                "key.annotated_decl" : "<Declaration>let graph: <Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type><\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>graph<\/decl.name>: <decl.var.type><ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class><\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 40,
                "key.name" : "graph",
                "key.namelength" : 5,
                "key.nameoffset" : 6467,
                "key.offset" : 6463,
                "key.parsed_declaration" : "let graph = self.first!.untyped[0].graph",
                "key.parsed_scope.end" : 178,
                "key.parsed_scope.start" : 178,
                "key.typename" : "DynamicGraph",
                "key.typeusr" : "$s4main12DynamicGraphCD",
                "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF5graphL_AA0bC0Cvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _graph: <Type usr=\"s:s13OpaquePointerV\">OpaquePointer<\/Type><\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_graph<\/decl.name>: <decl.var.type><ref.struct usr=\"s:s13OpaquePointerV\">OpaquePointer<\/ref.struct><\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 25,
                "key.name" : "_graph",
                "key.namelength" : 6,
                "key.nameoffset" : 6615,
                "key.offset" : 6611,
                "key.parsed_declaration" : "let _graph = graph._graph",
                "key.parsed_scope.end" : 184,
                "key.parsed_scope.start" : 184,
                "key.typename" : "OpaquePointer",
                "key.typeusr" : "$ss13OpaquePointerVD",
                "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF6_graphL_s13OpaquePointerVvp"
              },
              {
                "key.annotated_decl" : "<Declaration>var gradients: [<Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type>]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>gradients<\/decl.name>: <decl.var.type>[<ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class>]<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 65,
                "key.name" : "gradients",
                "key.namelength" : 9,
                "key.nameoffset" : 6645,
                "key.offset" : 6641,
                "key.parsed_declaration" : "var gradients = graph.gradients(for: self.flatMap { $0.untyped })",
                "key.parsed_scope.end" : 185,
                "key.parsed_scope.start" : 185,
                "key.typename" : "[DynamicGraph.AnyTensor]",
                "key.typeusr" : "$sSay4main12DynamicGraphC9AnyTensorCGD",
                "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF9gradientsL_SayAA0bC0C0D6TensorCGvp"
              },
              {
                "key.annotated_decl" : "<Declaration>var gradientsSet: <Type usr=\"s:Sh\">Set<\/Type>&lt;<Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/Type>&gt;<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>var<\/syntaxtype.keyword> <decl.name>gradientsSet<\/decl.name>: <decl.var.type><ref.struct usr=\"s:Sh\">Set<\/ref.struct>&lt;<ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.class usr=\"s:4main12DynamicGraphC9AnyTensorC\">AnyTensor<\/ref.class>&gt;<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 33,
                "key.name" : "gradientsSet",
                "key.namelength" : 12,
                "key.nameoffset" : 6715,
                "key.offset" : 6711,
                "key.parsed_declaration" : "var gradientsSet = Set(gradients)",
                "key.parsed_scope.end" : 186,
                "key.parsed_scope.start" : 186,
                "key.typename" : "Set<DynamicGraph.AnyTensor>",
                "key.typeusr" : "$sShy4main12DynamicGraphC9AnyTensorCGD",
                "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF12gradientsSetL_ShyAA0bC0C0D6TensorCGvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _inputs: [ccv_nnc_tensor_variable_t?]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_inputs<\/decl.name>: <decl.var.type>[ccv_nnc_tensor_variable_t?]<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 72,
                "key.name" : "_inputs",
                "key.namelength" : 7,
                "key.nameoffset" : 6930,
                "key.offset" : 6926,
                "key.parsed_declaration" : "let _inputs: [ccv_nnc_tensor_variable_t?] = gradients.map { $0._tensor }",
                "key.parsed_scope.end" : 193,
                "key.parsed_scope.start" : 193,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF7_inputsL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let inputSize: &lt;&lt;error type&gt;&gt;<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>inputSize<\/decl.name>: <decl.var.type>&lt;&lt;error type&gt;&gt;<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 36,
                "key.name" : "inputSize",
                "key.namelength" : 9,
                "key.nameoffset" : 7007,
                "key.offset" : 7003,
                "key.parsed_declaration" : "let inputSize = Int32(_inputs.count)",
                "key.parsed_scope.end" : 194,
                "key.parsed_scope.start" : 194,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF9inputSizeL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _outputs: &lt;&lt;error type&gt;&gt;<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_outputs<\/decl.name>: <decl.var.type>&lt;&lt;error type&gt;&gt;<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 104,
                "key.name" : "_outputs",
                "key.namelength" : 8,
                "key.nameoffset" : 7048,
                "key.offset" : 7044,
                "key.parsed_declaration" : "let _outputs = UnsafeMutablePointer<ccv_nnc_tensor_variable_t?>.allocate(\n  capacity: _inputs.count)",
                "key.parsed_scope.end" : 195,
                "key.parsed_scope.start" : 195,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF8_outputsL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let _streamContext: <Type usr=\"s:s13OpaquePointerV\">OpaquePointer<\/Type>?<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>_streamContext<\/decl.name>: <decl.var.type><ref.struct usr=\"s:s13OpaquePointerV\">OpaquePointer<\/ref.struct>?<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 43,
                "key.name" : "_streamContext",
                "key.namelength" : 14,
                "key.nameoffset" : 7408,
                "key.offset" : 7404,
                "key.parsed_declaration" : "let _streamContext = streamContext?._stream",
                "key.parsed_scope.end" : 204,
                "key.parsed_scope.start" : 204,
                "key.typename" : "OpaquePointer?",
                "key.typeusr" : "$ss13OpaquePointerVSgD",
                "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF01_iJ0L_s13OpaquePointerVSgvp"
              },
              {
                "key.annotated_decl" : "<Declaration>let f: [ccv_nnc_tensor_variable_t?]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>f<\/decl.name>: <decl.var.type>[ccv_nnc_tensor_variable_t?]<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 84,
                "key.name" : "f",
                "key.namelength" : 1,
                "key.nameoffset" : 7456,
                "key.offset" : 7452,
                "key.parsed_declaration" : "let f: [ccv_nnc_tensor_variable_t?] = self.flatMap { $0.untyped.map { $0._tensor } }",
                "key.parsed_scope.end" : 205,
                "key.parsed_scope.start" : 205,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF1fL_Xevp"
              },
              {
                "key.annotated_decl" : "<Declaration>let g: [ccv_nnc_tensor_variable_t?]<\/Declaration>",
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.var.local><syntaxtype.keyword>let<\/syntaxtype.keyword> <decl.name>g<\/decl.name>: <decl.var.type>[ccv_nnc_tensor_variable_t?]<\/decl.var.type><\/decl.var.local>",
                "key.groupname" : "Collection",
                "key.kind" : "source.lang.swift.decl.var.local",
                "key.length" : 90,
                "key.name" : "g",
                "key.namelength" : 1,
                "key.nameoffset" : 7545,
                "key.offset" : 7541,
                "key.parsed_declaration" : "let g: [ccv_nnc_tensor_variable_t?] = self.flatMap { $0.untyped.map { $0.grad?._tensor } }",
                "key.parsed_scope.end" : 206,
                "key.parsed_scope.start" : 206,
                "key.typename" : "<<error type>>",
                "key.typeusr" : "$sXeD",
                "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF1gL_Xevp"
              }
            ],
            "key.typename" : "<Self, S where Self : Collection, S : Sequence, Self.Element : DynamicGraph_AnyGroup, S.Element : DynamicGraph_AnyGroup> (Self) -> (S, StreamContext?) -> ()",
            "key.typeusr" : "$s2to13streamContextyqd___4main06StreamC0CSgtcSTRd__AC21DynamicGraph_AnyGroup7ElementRpd__luD",
            "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF"
          },
          {
            "key.accessibility" : "source.lang.swift.accessibility.public",
            "key.annotated_decl" : "<Declaration>public func backward&lt;Group&gt;(to tensor: <Type usr=\"s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtAaBRd__lF0E0L_qd__mfp\">Group<\/Type>, streamContext: <Type usr=\"s:4main13StreamContextC\">StreamContext<\/Type>? = nil) where Group : <Type usr=\"s:4main21DynamicGraph_AnyGroupP\">DynamicGraph_AnyGroup<\/Type><\/Declaration>",
            "key.attributes" : [
              {
                "key.attribute" : "source.decl.attribute.public",
                "key.length" : 6,
                "key.offset" : 8009
              }
            ],
            "key.bodylength" : 60,
            "key.bodyoffset" : 8124,
            "key.doc.column" : 15,
            "key.doc.comment" : " Compute gradients from this tensor to the source tensor.\n\n - Parameters:\n   - to: The source tensor to this tensor.\n   - streamContext: The stream context to perform such operation.",
            "key.doc.declaration" : "public func backward<Group>(to tensor: Group, streamContext: StreamContext? = nil) where Group : main.DynamicGraph_AnyGroup",
            "key.doc.file" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.doc.full_as_xml" : "<Function file=\"\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift\" line=\"219\" column=\"15\"><Name>backward(to:streamContext:)<\/Name><USR>s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtAaBRd__lF<\/USR><Declaration>public func backward&lt;Group&gt;(to tensor: Group, streamContext: StreamContext? = nil) where Group : main.DynamicGraph_AnyGroup<\/Declaration><CommentParts><Abstract><Para>Compute gradients from this tensor to the source tensor.<\/Para><\/Abstract><Parameters><Parameter><Name>to<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The source tensor to this tensor.<\/Para><\/Discussion><\/Parameter><Parameter><Name>streamContext<\/Name><Direction isExplicit=\"0\">in<\/Direction><Discussion><Para>The stream context to perform such operation.<\/Para><\/Discussion><\/Parameter><\/Parameters><\/CommentParts><\/Function>",
            "key.doc.line" : 219,
            "key.doc.name" : "backward(to:streamContext:)",
            "key.doc.parameters" : [
              {
                "discussion" : [
                  {
                    "Para" : "The source tensor to this tensor."
                  }
                ],
                "name" : "to"
              },
              {
                "discussion" : [
                  {
                    "Para" : "The stream context to perform such operation."
                  }
                ],
                "name" : "streamContext"
              }
            ],
            "key.doc.type" : "Function",
            "key.doclength" : 212,
            "key.docoffset" : 7794,
            "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
            "key.fully_annotated_decl" : "<decl.function.method.instance><syntaxtype.keyword>public<\/syntaxtype.keyword> <syntaxtype.keyword>func<\/syntaxtype.keyword> <decl.name>backward<\/decl.name>&lt;<decl.generic_type_param usr=\"s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtAaBRd__lF0E0L_qd__mfp\"><decl.generic_type_param.name>Group<\/decl.generic_type_param.name><\/decl.generic_type_param>&gt;(<decl.var.parameter><decl.var.parameter.argument_label>to<\/decl.var.parameter.argument_label> <decl.var.parameter.name>tensor<\/decl.var.parameter.name>: <decl.var.parameter.type><ref.generic_type_param usr=\"s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtAaBRd__lF0E0L_qd__mfp\">Group<\/ref.generic_type_param><\/decl.var.parameter.type><\/decl.var.parameter>, <decl.var.parameter><decl.var.parameter.argument_label>streamContext<\/decl.var.parameter.argument_label>: <decl.var.parameter.type><ref.class usr=\"s:4main13StreamContextC\">StreamContext<\/ref.class>?<\/decl.var.parameter.type> = nil<\/decl.var.parameter>) <syntaxtype.keyword>where<\/syntaxtype.keyword> <decl.generic_type_requirement>Group : <ref.protocol usr=\"s:4main21DynamicGraph_AnyGroupP\">DynamicGraph_AnyGroup<\/ref.protocol><\/decl.generic_type_requirement><\/decl.function.method.instance>",
            "key.groupname" : "Collection",
            "key.kind" : "source.lang.swift.decl.function.method.instance",
            "key.length" : 169,
            "key.name" : "backward(to:streamContext:)",
            "key.namelength" : 101,
            "key.nameoffset" : 8021,
            "key.offset" : 8016,
            "key.parsed_declaration" : "public func backward<Group: DynamicGraph.AnyGroup>(\n  to tensor: Group, streamContext: StreamContext? = nil\n)",
            "key.parsed_scope.end" : 223,
            "key.parsed_scope.start" : 219,
            "key.related_decls" : [
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AeFRcd__lF\">backward&lt;S&gt;(to: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : DynamicGraph.AnyTensor<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sl4mainAA12DynamicGraphC9AnyTensorC7ElementRczrlE8backward2to13streamContextyAE_AA06StreamJ0CSgtF\">backward(to: DynamicGraph.AnyTensor, streamContext: StreamContext? = nil)<\/RelatedName>"
              },
              {
                "key.annotated_decl" : "<RelatedName usr=\"s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtSTRd__AabCRpd__lF\">backward&lt;S&gt;(to: S, streamContext: StreamContext? = nil) where S : Sequence, S.Element : DynamicGraph_AnyGroup<\/RelatedName>"
              }
            ],
            "key.substructure" : [
              {
                "key.annotated_decl" : "<Declaration>Group : <Type usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/Type>.<Type usr=\"s:4main12DynamicGraphC8AnyGroupa\">AnyGroup<\/Type><\/Declaration>",
                "key.elements" : [
                  {
                    "key.kind" : "source.lang.swift.structure.elem.typeref",
                    "key.length" : 21,
                    "key.offset" : 8037
                  }
                ],
                "key.filepath" : "\/home\/liu\/Dropbox\/workspace\/s4nnc\/nnc\/AutoGrad.swift",
                "key.fully_annotated_decl" : "<decl.generic_type_param><decl.generic_type_param.name>Group<\/decl.generic_type_param.name> : <decl.generic_type_param.constraint><ref.class usr=\"s:4main12DynamicGraphC\">DynamicGraph<\/ref.class>.<ref.typealias usr=\"s:4main12DynamicGraphC8AnyGroupa\">AnyGroup<\/ref.typealias><\/decl.generic_type_param.constraint><\/decl.generic_type_param>",
                "key.groupname" : "Collection",
                "key.inheritedtypes" : [
                  {
                    "key.name" : "DynamicGraph.AnyGroup"
                  }
                ],
                "key.kind" : "source.lang.swift.decl.generic_type_param",
                "key.length" : 28,
                "key.name" : "Group",
                "key.namelength" : 5,
                "key.nameoffset" : 8030,
                "key.offset" : 8030,
                "key.parsed_declaration" : "public func backward<Group: DynamicGraph.AnyGroup",
                "key.parsed_scope.end" : 219,
                "key.parsed_scope.start" : 219,
                "key.typename" : "Group.Type",
                "key.typeusr" : "$sqd__mD",
                "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtAaBRd__lF0E0L_qd__mfp"
              }
            ],
            "key.typename" : "<Self, Group where Self : Collection, Group : DynamicGraph_AnyGroup, Self.Element : DynamicGraph_AnyGroup> (Self) -> (Group, StreamContext?) -> ()",
            "key.typeusr" : "$s2to13streamContextyqd___4main06StreamC0CSgtcAC21DynamicGraph_AnyGroupRd__luD",
            "key.usr" : "s:Sl4mainAA21DynamicGraph_AnyGroup7ElementRpzrlE8backward2to13streamContextyqd___AA06StreamJ0CSgtAaBRd__lF"
          }
        ],
        "key.typename" : "Collection.Protocol",
        "key.typeusr" : "$sSl_pmD",
        "key.usr" : "s:Sl"
      }
    ]
  }
}
